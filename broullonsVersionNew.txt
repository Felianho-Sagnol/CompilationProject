===================================== ligne de commande ========================================
 /c/Users/gobou/Mescours/Courss6/Compilation/ProjetCompilation__Compilateur
 bison -d -oGuiSyntaxe.c GuiSyntaxe.y
flex -oGuiComp.c GuiAnalyseur.l
gcc GuiSyntaxe.c GuiComp.c -o programme
./programme Algo.txt

============================================ bison .y==========================================


listInstruction :instruction 
				|
				listInstruction instruction 
				;
			
instruction :	affichage 
				|
				affectation 
				|
				condition
				|
				boucle
				|
				lecture
				|
				commentaire
				|
				INLINE
				;
boucle :		for
				|
				while
				;
for		:		FOR IDENTIFINT CRO_O ENTIER VIRGUL ENTIER CRO_F INLINE listInstruction POINT INLINE
				;
while	:		FOR CRO_O comparaison CRO_F INLINE listInstruction POINT INLINE
				;

commentaire :	COMMENT CHAINE INLINE
				; 
lecture :		READ CRO_O expression CRO_F INLINE
				;
affichage :		WRITE CRO_O contenu CRO_F INLINE
				;
contenu: simple_affichage
		|
		texte
		|
		concat
        ;
concat: texte POINT simple_affichage
		|
		simple_affichage POINT texte
		|
		texte POINT simple_affichage POINT texte
		;
texte:	GRIF list_chaine GRIF
		;
list_chaine:  CHAINE 
			|
			list_chaine CHAINE
			;
simple_affichage:ENTIER
				|
				IDENTIFINT
				;

affectation :	IDENTIFINT EGAL expression INLINE
				{
					//printf("var ======== %s\n",$1);
				}
				;
condition: 		condition_si POINT INLINE
            	|
            	condition_si POINT INLINE condition_sinon 
            	|
            	condition_si POINT INLINE list_condition_sinon_si 
            	;
list_condition_sinon_si: condition_sinon_si POINT INLINE
						|
						condition_sinon_si POINT INLINE condition_sinon 
						|
						list_condition_sinon_si condition_sinon_si POINT INLINE
                         ;
condition_sinon_si:SINONSI CRO_O comparaison CRO_F INLINE listInstruction 
 				; 
condition_si  :SI CRO_O comparaison CRO_F INLINE listInstruction 
				;
condition_sinon: SINON INLINE listInstruction POINT INLINE
				;

comparaison: IDENTIFINT signe_comparaison expression
				;
signe_comparaison: EGALCONDI 
				   |
				   SUPEG 
				   |
				   INFEG
				   |
				   INF
				   |
				   SUP
				   |
				   DIFF
				   ;
expression :	IDENTIFINT
				|
				ENTIER
				;	

 =================================================lexical========================================================
%{
	#include <stdio.h>
	#include <stdlib.h>
    #include <string.h>
	#include "GuiSyntaxe.h"
	unsigned int lineNumber=1;
	int valEntier;
 	char valIdentif[256];
	char valChaine[255];
%}

nbr [0-9]
entier {nbr}+
identifInt @n_[a-zA-Z][0-9a-zA-Z_]*
identifStr @s_[a-zA-Z][0-9a-zA-Z_]*
chaine [a-zA-Z][0-9a-zA-Z_ -@]*



%%
"Gui"          { ECHO; return GUI; }
"nea"        { ECHO; return NEA; }
"write"      { ECHO; return WRITE; }
"read"       { ECHO; return READ; }
"function"   { ECHO; return FUNCTION; }
"#"          { ECHO; return SI; }
"!"          { ECHO; return SINON; }
"["          { ECHO; return CRO_O; }
"]"          { ECHO; return CRO_F; }
"!#"         { ECHO; return SINONSI; }
"##"         { ECHO; return FOR;}
"//"         { ECHO; return COMMENT;}
"!="         { ECHO; return DIFF; }
"=="         { ECHO; return EGALCONDI; }
"="          { ECHO ; return EGAL;}
"<="         { ECHO; return INFEG; }
">="         { ECHO; return SUPEG; }
"<"          { ECHO; return INF; }
">"          { ECHO; return SUP; }
"."          { ECHO; return POINT;}
","          { ECHO; return VIRGUL;}
"\""         { ECHO; return GRIF;}
"-"          { ECHO; return MOINS;}
"*"          { ECHO; return MUL;}
"("          { ECHO; return PA_O; }
")"          { ECHO; return PA_F; }
"/"          { ECHO; return DIV;}
"%"          { ECHO; return MODULO;}
"+"          { ECHO; return PLUS;}
"\n"         {ECHO; lineNumber++;return INLINE;}
[" "\t]      { }
{entier}     { ECHO; yylval.entier = atoi(yytext); return ENTIER; };
{identifInt}    { ECHO;strcpy(yylval.var, yytext); return IDENTIFINT; };
{identifStr}    { ECHO;strcpy(yylval.var, yytext); return IDENTIFSTR; };

{chaine}    { strcpy(yylval.var, yytext); return CHAINE; }

. {
    fprintf(stderr,"\tERREUR LEXICAL: Lexeme inconnu a la ligne %d. Il s'agit de %s et comporte %d lettre(s)\n",lineNumber,yytext,yyleng);
}
%%
int valEntier;
char valIdentif[256];
char valChaine[255];
int yywrap(void) {
return 1;
}


 =================================================syntax=======================================
 %{
	#include <stdio.h>
	#include <stdlib.h>
    #include <string.h>
	extern FILE* yyin;
	extern int valEntier;
    extern char valIdentif[256];
    extern char valChaine[255];
	int yylex(void); // defini dans progL.cpp, utilise par yyparse()
	void yyerror(char * msg);
	extern unsigned int lineNumber; // notre compteur de lignes

    typedef struct {
      	char *identif;
       	int type;
		union
		{
			int intValue;
			char* charValue;
		} valeur;
    } ENTREE_DICO;

#define TAILLE_INITIALE_DICO 50
#define INCREMENT_TAILLE_DICO 25

char TOKENS[5][8]={"Gui","nea","write","read", "CONST"};
ENTREE_DICO *dico;
int maxDico, sommet, base;

void creerDico(void) {
    maxDico = TAILLE_INITIALE_DICO;
    dico = malloc(maxDico * sizeof(ENTREE_DICO));
    if (dico == NULL)
        yyerror("Erreur interne (pas assez de mémoire)");
    sommet = base = 0;
}

void agrandirDico(void) {
    maxDico = maxDico + INCREMENT_TAILLE_DICO;
    dico = realloc(dico, maxDico);
    if (dico == NULL)
        yyerror("Erreur interne (pas assez de mémoire)");
}
int isToken(char *s){
	for(int i=0;i<3;i++)
	{
		if(strcmp(s,TOKENS[i])==0)
		{
			return 1;
		}else{
		   return 0;
		}
		
	}
}
int isDeclared(char *s){
	for(int i=0;i<sommet;i++){
		if(strcmp(s,dico[i].identif)==0) {
           return 1;
		}
	}
	return 0;
}

void AjoutIdentif(char *identif,int type) {
	if(isToken(identif)==1) {
		printf("ERREUR --- linge %d :  Nom de variable est un mot cle\n",lineNumber-1);
		exit(-1);
	}
    if(isDeclared(identif)==1) {
		printf("ERREUR --- linge %d : Variable => %s deja declaree\n", lineNumber-1,identif);
		exit(-2);
	}
    if (sommet >= maxDico)
        agrandirDico();

    dico[sommet].identif = malloc(strlen(identif) + 1);
    if (dico[sommet].identif == NULL){
		printf("Erreur interne pas assez de mémoire)");
		exit(-1);
	}
        
    strcpy(dico[sommet].identif, identif);
    dico[sommet].type = type;
	if(type == 0){
		dico[sommet].valeur.intValue = 0;
	}else{
		dico[sommet].valeur.charValue = "";
	}
    sommet++;
}

void noDeclareError(char *s){
	printf("------%s--------",s);
	/*if(isDeclared(s)==0){
		printf("*ERROR*-- la variable %s n est pas declare Ligne %d\n",s,lineNumber-1);
		exit(-2);
	}*/
}
void printDico(){
	for(int i=0;i<sommet;i++){
		printf("NomVariable:  %s\n TypeVariable: %d \n",dico[i].identif,dico[i].type);
		if(dico[i].type==0)
		{
			printf("ValVariable: %d\n",dico[i].valeur.intValue);
		}
		else 	printf("ValVariable: %s\n",dico[i].valeur.charValue);
	}
}

int isInt(char *s){
	char c[4];
	strcpy(c,"");
	strncat(c,s,2);
	if(strcmp("@n",c)==0) return 0;
	else return 1;
}

void setValue(char *s,char *v){
	int type = isInt(s);
	for(int i=0;i<sommet;i++){
		if(strcmp(s,dico[i].identif)==0){
			if(type==0){
				dico[i].valeur.intValue = atoi(v);
			}else{
				strcpy(dico[i].valeur.charValue,v);
			}
			break;
		} 
	}
}

int getIntValue(char *s){
	int type = isInt(s);
	for(int i=0;i<sommet;i++){
		if(strcmp(s,dico[i].identif)==0){
			if(type==0){
				return dico[i].valeur.intValue;
			}
			break;
		} 
	}
}

char *getCharValue(char *s){
	int type = isInt(s);
	for(int i=0;i<sommet;i++){
		if(strcmp(s,dico[i].identif)==0){
			if(type==1){
				return dico[i].valeur.charValue;
			}
			break;
		} 
	}
}



%}
%left PLUS MOINS
%left MUL DIV

%union{
	char* var;
	int entier;
}



%token	ENTIER
%token	IDENTIFINT
%token	IDENTIFSTR

%token<var> GUI  NEA  
%token<var>	CRO_O CRO_F SI EGAL DIFF SINON SINONSI 
%token<var> WRITE READ INFEG SUPEG INF SUP FOR CHAINE POINT
%token<var> INLINE EGALCONDI GRIF PLUS MOINS MUL MODULO DIV  COMMENT VIRGUL FUNCTION VIDE

%start program

%%
program : IDENTIFSTR INLINE IDENTIFINT;
%%		

void yyerror(char * msg){
	printf("\t Ligne %d : %s\n", lineNumber, msg);
}
int main(int argc,char ** argv){
	if(argc>1) yyin=fopen(argv[1],"r"); // check result !!!
	lineNumber=1;
	if(!yyparse())
	printf("Expression correct\n");
	return(0);
}               